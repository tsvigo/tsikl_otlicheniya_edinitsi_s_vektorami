#include "dialog.h"
#include "ui_dialog.h"
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Dialog::Dialog
/// \param parent
#include <fstream>
#include <iostream>
#include <vector>
//#include <ifstream>
#include <algorithm>
#include <iterator>
using namespace std;
#include "klass_neyronnaya_sety.h"
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
std::vector<unsigned long long> list_sinapsov;//(10105);// = {};
std::vector<unsigned long long> list_neyronov;//(202);// = {};
//extern     long long oshibka;
//long long Peremennaya_Oshibka;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Dialog::Dialog(QWidget *parent) : QDialog(parent), ui(new Ui::Dialog) {
  ui->setupUi(this);
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////// (1) //// Считывание из файла нейронов в
  ///массив:
  ///////////////////////////////////////////////////////////////////////////////////////////////
  try {

    
   unsigned long long n;    
   // std::vector<int>list_neyronov;
    ifstream file("/home/viktor/my_projects_qt_2/Funkciya_podachi_signalov_na_vhod/neyroni_i_signal.txt");
        if (!file) {
          std::cerr << "ERROR: Cannot open "
                       "'/home/viktor/my_projects_qt_2/"
                       "Funkciya_podachi_signalov_na_vhod/neyroni_i_signal.txt'!"
                    << std::endl;
          //  exit(1);
        }
    while (!file.eof()) 
    {        file >> n;        list_neyronov.push_back(n);       // cout << n << endl;
    } 
        file.close();
      //  std::cout << list_neyronov[1] << std::endl;

  } catch (const std::exception &ex) {
    std::cerr << "Exception: '" << ex.what() << "'!" << std::endl;
    //  exit(1);
  }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  
  //////////////////////////////// (1) ///// Конец считывания из файла нейронов  ///в массив. ////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ///
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////// (2) //// Считывание из файла синапсов в  ///массив:
  ///////////////////////////////////////////////////////////////////////
  try {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
unsigned long long n;    

ifstream file2(
    
 "/home/viktor/my_projects_qt_2/build-zapolnenie_sinapsov_sluchajnymi_nachalnymi_soprotivleniyami_2-Desktop_Qt_5_12_12_GCC_64bit-Debug/sinapsi.txt"
               
 //              "/home/viktor/my_projects_qt_2/zapolnenie_0/0_sinapsi.txt"
               
               );




if (!file2) {
    std::cerr << "ERROR: Cannot open "
                 "'/home/viktor/my_projects_qt_2/"
                 "build-zapolnenie_sinapsov_sluchajnymi_nachalnymi_soprotivleniyami_2-"
                 "Desktop_Qt_5_12_12_GCC_64bit-Debug/sinapsi.txt'!"
              << std::endl;
    //  exit(1);
}
while (!file2.eof()) 
{        file2 >> n;        list_sinapsov.push_back(n);       // cout << n << endl;
} 
    file2.close();
 //   std::cout << list_sinapsov[1] << std::endl;

  }
  
  catch (const std::exception &ex) {
    std::cerr << "Exception: '" << ex.what() << "'!" << std::endl;
    //  exit(1);
  }
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////// (3) Функция решения   /// funktsiya_resheniya // NOTE: функция решения
  //
  //////////////////////////////////////////////////////////////////////
  /// \brief Klass_Neyronnaya_sety::Funktciia_resheniya

  Klass_Neyronnaya_sety::Funktciia_resheniya(); // NOTE:  Klass_Neyronnaya_sety::Funktciia_resheniya();

 // std::cout << "ошибка = "  << Klass_Neyronnaya_sety::Peremennaya_Oshibka << std::endl;

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// 
  ///  далее кнопка "Неправильно" запускает процесс подстройки сопротивлений синапсов
  ///  а может без кнопки если заведомо известно что есть ошибка
  /// /// Уменьшаем ... синапс на 1 и пересчитываем ошибку в смысле сначала снова функция решения а потом считаем ошибку.
  ///  Видима нужна какая-то глобальная переменная хранящая текущий синапс... int tekuschiy_sinaps... Начинаем видимо с 0
  ///  int tekuschiy_sinaps=0; на закрытие программы неплохо её в файл писать. А как насчёт действия - вычитать по 1 из синапсов или прибавлять?
  /// Вроде вычитать. Значит берём синапс с индексом 0 и вычитаем из него 1
  /// list_sinapsov[0]=list_sinapsov[0]-1;
  /// Может проверить крайнее положение когда все синапсы по нулям?
  /// И все 0 и все максимальные минусы: -2147483647 вообще не уменьшают ошибку
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// 
  /// 
  /// 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// 
 // Тут нужна функция изменения синапса. Точнее уменьшения синапса на 1. Надо ли границу проверять?
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
// list_sinapsov[0]=list_sinapsov[0]-1; // первый изначальный синапс под индексом 0 = 1740539749
//// std::cout << "ошибка = "  << "list_sinapsov[0] = "<< list_sinapsov[0] << std::endl;
// // снова решаем - то есть получаем ошибку
//  Klass_Neyronnaya_sety::Funktciia_resheniya();
// // снова проверяем ошибку
//  int index_sinapsa=1;
//a:  if (Klass_Neyronnaya_sety::Peremennaya_Oshibka>0 && index_sinapsa<10103 )
//  {
//      list_sinapsov[index_sinapsa]=list_sinapsov[index_sinapsa]-1;
//      index_sinapsa=index_sinapsa+1;
//      Klass_Neyronnaya_sety::Funktciia_resheniya();
//      goto a;
//  }
//////////// или: //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  int index_sinapsa;
  b: // если  последний синапс дошёл до минимума то выходим из goto b
    if (list_sinapsov[10101]==0) goto c;
  for ( index_sinapsa=0; // начинаем с первого синапса
           Klass_Neyronnaya_sety::Peremennaya_Oshibka>0 ; // проверяем ошибку
           index_sinapsa=index_sinapsa+1) // продвигаем индекс синапса на 1
  {
          // возможно тут условие проверить синапс на минимальное значение
      if (list_sinapsov[index_sinapsa]>0)
      list_sinapsov[index_sinapsa]=list_sinapsov[index_sinapsa]-1; // сегментация фаулт: index_sinapsa=16894
         Klass_Neyronnaya_sety::Funktciia_resheniya();
      // тут видимо надо проверку выхода за нижнюю границу величины синапса
         // первый раз вычел по 1
    }
  // сюда выходим либо если прошли до последнего 10101 либо если ошибка пропала
    // 1. Если прошли до 10101 но ошибка не пропала то обнуляем индекс синапса и идём goto b
    if (index_sinapsa==10101 && Klass_Neyronnaya_sety::Peremennaya_Oshibka>0 )
        goto b;
    // 2. Если ошибка пропала но не дошли до 10101 надо записать синапсы в файл
    if (Klass_Neyronnaya_sety::Peremennaya_Oshibka<=0)
    {
        
    }
        // записать вектор в файл // TODO: записать вектор в файл и записать что ошибка пропала и идти goto c;
    // 3. И ошибка и пропала и довычитались до того что все синапсы приняли минимальные значения (последний 10101 синапс стал минимальным)
    // unsigned long long какое минимум?
    
 //   index_sinapsa=0;
    // если не все синапсы достигли минимального значения и/или ошибка есть (больше 0)
    // если 1) синапс с индексом 101 (последний ) не достиг минимального значения
    // если 2) Klass_Neyronnaya_sety::Peremennaya_Oshibka>0 ? 4 случайных сочетания? // NOTE: останов.
    
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    
// Но не тут то было тут я повычитаю из каждого синапса по 1 и надо снова переходить к первому синапсу с индексом 0. То есть поставить условие
// что когда индекс синапса становится последним (10101) он обнуляется
    // Accessing last element 
    int n = list_sinapsov.size();
  cout << list_sinapsov[n - 1]<< "\n" << "индекс последнего элемента = " << n-1 << endl;
  //  индекс последнего элемента = 10101
  c:  if (list_sinapsov[10101]==0)
      {
           cout  << "Все синапсы имеют минимальные значения."  << endl;
      }    
      // тут написать что все синапсы имеют минимальные значения
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
} // Dialog::Dialog(QWidget *parent)

Dialog::~Dialog() { delete ui; }






















